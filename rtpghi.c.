#include "ltfat.h"
#include "ltfat/macros.h"
#include "ltfat/types.h"
#include "rtpghi.h"

struct rtpghi_state
{
    rtpghiupdate_plan* p;
    ltfat_int M;
    ltfat_int a;
    ltfat_int W;
    double* s;
    double* tgrad; 
    double* fgrad;
    double* phase;
    double* phasein;
    double stretch;
};

struct rtpghiupdate_plan
{
    heap* h;
    int* donemask;
    double tol;
    ltfat_int M;
    double* randphase;
    ltfat_int randphaseLen;
    ltfat_int randphaseId;
};




static double
princarg(const double in)
{
    return (double) ( in - 2.0 * M_PI * round(in / (2.0 * M_PI)) );
}

static int
shiftcolsleft(double* cols, ltfat_int height, ltfat_int N,
                          const double* newcol)
{
    for (ltfat_int n = 0; n < N - 1; n++)
        memcpy(cols + n * height, cols + (n + 1)*height, height * sizeof * cols);

    if (newcol)
        memcpy(cols + (N - 1)*height, newcol, height * sizeof * cols);
    else
        memset(cols + (N - 1)*height, 0, height * sizeof * cols);

    return 0;
}

static void
rtpghi_abs(const LTFAT_COMPLEX in[], ltfat_int height,
                       double out[])
{
    for (ltfat_int ii = 0; ii < height; ii++)
        out[ii] = ltfat_abs(in[ii]);
}

static void
rtpghi_phase(const LTFAT_COMPLEX in[], ltfat_int height,
                         double out[])
{
    for (ltfat_int ii = 0; ii < height; ii++)
        out[ii] = ltfat_arg(in[ii]);
}

LTFAT_API double
rtpghi_get_stretch(rtpghi_state* p)
{
    return p->stretch;
}

LTFAT_API void
rtpghi_init_stretch(rtpghi_state* p, double stretch)
{
    p->stretch = stretch;
}

LTFAT_API int
rtpghi_set_tol(rtpghi_state* p, double tol)
{
    int status = LTFATERR_SUCCESS;
    CHECKNULL(p);
    CHECK(LTFATERR_NOTINRANGE, tol > 0 && tol < 1, "tol must be in range ]0,1[");

    p->p->tol = tol;
error:
    return status;
}

LTFAT_API int
rtpghi_init(ltfat_int W, ltfat_int a, ltfat_int M,
                        double tol, rtpghi_state** pout)
{
    int status = LTFATERR_SUCCESS;

    ltfat_int M2 = M / 2 + 1;
    rtpghi_state* p = NULL;

    CHECK(LTFATERR_NOTPOSARG, W > 0, "W must be positive");
    CHECK(LTFATERR_NOTPOSARG, a > 0, "a must be positive (passed %d)", a);
    CHECK(LTFATERR_NOTPOSARG, M > 0, "M must be positive");
    CHECK(LTFATERR_NOTINRANGE, tol > 0 && tol < 1, "tol must be in range ]0,1[");

    CHECKMEM( p = (rtpghi_state*) ltfat_calloc(1, sizeof * p));

    CHECKSTATUS( rtpghiupdate_init( M, W, tol, &p->p));
    CHECKMEM( p->s =       LTFAT_NAME_REAL(calloc)(3 * M2 * W));
    CHECKMEM( p->tgrad =   LTFAT_NAME_REAL(calloc)(2 * M2 * W));
    CHECKMEM( p->fgrad =   LTFAT_NAME_REAL(calloc)(1 * M2 * W));
    CHECKMEM( p->phase =   LTFAT_NAME_REAL(calloc)(1 * M2 * W));
    CHECKMEM( p->phasein = LTFAT_NAME_REAL(calloc)(3 * M2 * W));

    p->M = M;
    p->a = a;
    p->W = W;
    p->stretch = 1.0;

    *pout = p;
    return status;
error:
    if (p) rtpghi_done(&p);
    return status;
}

LTFAT_API int
rtpghi_reset(rtpghi_state* p,
                         const double** sinit)
{
    int status = LTFATERR_SUCCESS;
    ltfat_int M2, W;
    CHECKNULL(p);
    M2 = p->M / 2 + 1;
    W = p->W;

    memset(p->s, 0,     3 * M2 * W * sizeof * p->s);
    memset(p->tgrad, 0, 2 * M2 * W * sizeof * p->tgrad);
    memset(p->fgrad, 0, 1 * M2 * W * sizeof * p->tgrad);
    memset(p->phase, 0, 1 * M2 * W * sizeof * p->phase);
    memset(p->phasein, 0, 3 * M2 * W * sizeof * p->phase);

    if (sinit)
        for (ltfat_int w = 0; w < W; w++)
            if (sinit[w])
            {
                memcpy(p->s + 2 * w * M2, sinit[w], 2 * M2 * sizeof * p->s );
            }

error:
    return status;
}

LTFAT_API int
rtpghi_execute(rtpghi_state* p,
                           const LTFAT_COMPLEX cin[], double stretch, LTFAT_COMPLEX cout[])
{
    // n, n-1, n-2 frames
    // s is n-th
    ltfat_int M2, W, asyn, aanaprev, aananext;
    double stretchmid;
    int status = LTFATERR_SUCCESS;
    CHECKNULL(p); CHECKNULL(cin); CHECKNULL(cout);
    M2 = p->M / 2 + 1; W = p->W;
    asyn = p->a;
    aanaprev = round(asyn / p->stretch); // old stretch
    aananext = round(asyn / stretch); // new stretch

    for (ltfat_int w = 0; w < W; ++w)
    {
        double* sCol       = p->s       + 3 * w * M2;
        double* tgradCol   = p->tgrad   + 2 * w * M2;
        double* fgradCol   = p->fgrad   + 1 * w * M2;
        double* phaseCol   = p->phase   + 1 * w * M2;
        double* phaseinCol = p->phasein + 3 * w * M2;

        shiftcolsleft(sCol, M2, 3, NULL);
        shiftcolsleft(tgradCol, M2, 2, NULL);
        shiftcolsleft(phaseinCol, M2, 3, NULL);

        rtpghi_abs(cin + w * M2,   M2, sCol + 2 * M2);

        rtpghi_phase(cin + w * M2, M2, phaseinCol + 2 * M2);

        rtpghitgrad(phaseinCol, aanaprev, aananext, p->M, p->stretch,
                                tgradCol + M2);

        if (ltfat_abs(stretch - 1.0) < 1e-4)
        {
            memcpy(phaseCol, phaseinCol + M2, M2 * sizeof * phaseCol);
        }
        else
        {
            rtpghifgrad(phaseinCol + M2, p->M, p->stretch, fgradCol);

            rtpghiupdate_execute(p->p,
                                             sCol, tgradCol, fgradCol, phaseCol, phaseCol);
        }
        rtpghimagphase( sCol + M2, phaseCol, M2, cout + w * M2);
    }

    p->stretch = stretch;
error:
    return status;
}

LTFAT_API int
rtpghi_done(rtpghi_state** p)
{
    int status = LTFATERR_SUCCESS;
    rtpghi_state* pp;
    CHECKNULL(p); CHECKNULL(*p);
    pp = *p;
    if (pp->p)     rtpghiupdate_done(&pp->p);
    if (pp->s)     ltfat_free(pp->s);
    if (pp->phase) ltfat_free(pp->phase);
    if (pp->tgrad) ltfat_free(pp->tgrad);
    if (pp->fgrad) ltfat_free(pp->fgrad);
    ltfat_free(pp);
    pp = NULL;
error:
    return status;
}

LTFAT_API int
rtpghiupdate_init(ltfat_int M, ltfat_int W, double tol,
                              rtpghiupdate_plan** pout)
{
    int status = LTFATERR_SUCCESS;

    ltfat_int M2 = M / 2 + 1;
    rtpghiupdate_plan* p = NULL;
    CHECKMEM( p = (rtpghiupdate_plan*) ltfat_calloc(1, sizeof * p));
    CHECKMEM( p->donemask = (int*) ltfat_calloc(M2, sizeof * p->donemask));

    p->randphaseLen = 10 * M2 * W;
    CHECKMEM( p->randphase = LTFAT_NAME_REAL(malloc)(p->randphaseLen));

    for (ltfat_int ii = 0; ii < p->randphaseLen; ii++)
        p->randphase[ii] = 2.0 * M_PI * ((double)rand()) / RAND_MAX;

    p->tol = tol;
    p->M = M;
    p->randphaseId = 0;
    p->h = heap_init(2 * M2, NULL);

    *pout = p;
    return status;
error:
    if (p) rtpghiupdate_done(&p);
    return status;
}

LTFAT_API int
rtpghiupdate_execute_withmask(LTFAT_NAME(
            rtpghiupdate_plan)* p,
        const double s[],
        const double tgrad[],
        const double fgrad[],
        const double startphase[],
        const int mask[], double phase[])
{
    ltfat_int M2 = p->M / 2 + 1;
    memcpy(p->donemask, mask, M2 * sizeof * p->donemask);

    return rtpghiupdate_execute_common(p, s, tgrad, fgrad,
            startphase, phase);
}

// s: M2 x 2
// tgrad: M2 x 2
// fgrad: M2 x 1
// startphase: M2 x 1
// phase: M2 x 1
// donemask: M2 x 1
// heap must be able to hold 2*M2 values
LTFAT_API int
rtpghiupdate_execute(rtpghiupdate_plan* p,
                                 const double s[],
                                 const double tgrad[],
                                 const double fgrad[],
                                 const double startphase[],
                                 double phase[])
{
    ltfat_int M2 = p->M / 2 + 1;
    memset(p->donemask, 0, M2 * sizeof * p->donemask);

    return rtpghiupdate_execute_common(p, s, tgrad, fgrad,
            startphase, phase);
}


LTFAT_API int
rtpghiupdate_execute_common(rtpghiupdate_plan* p,
                                        const double s[],
                                        const double tgrad[],
                                        const double fgrad[],
                                        const double startphase[],
                                        double phase[])
{
    heap* h = p->h;
    ltfat_int M2 = p->M / 2 + 1;
    ltfat_int quickbreak = M2;
    const double oneover2 = (double) ( 1.0 / 2.0 );
    int* donemask = p->donemask;
    const double* slog2 = s + M2;

    double logabstol = s[0];
    for (ltfat_int m = 1; m < 2 * M2; m++)
        if (s[m] > logabstol)
            logabstol = s[m];

    logabstol *= p->tol;

    heap_reset(h, s);

    for (ltfat_int m = 0; m < M2; m++)
    {
        if ( donemask[m] > 0 )
        {
            heap_insert(h, m + M2);
            quickbreak--;
        }
        else
        {
            if ( slog2[m] <= logabstol )
            {
                donemask[m] = -1;
                quickbreak--;
            }
            else
            {
                heap_insert(h, m);
            }
        }
    }

    ltfat_int w = -1;
    while ( (quickbreak > 0) && ( w = heap_delete(h) ) >= 0 )
    {
        if ( w >= M2 )
        {
            ltfat_int wprev = w - M2;

            if ( wprev != M2 - 1 && !donemask[wprev + 1] )
            {
                phase[wprev + 1] = phase[wprev] + (fgrad[wprev] + fgrad[wprev + 1]) * oneover2;
                donemask[wprev + 1] = 1;

                heap_insert(h, w + 1);
                quickbreak--;
            }

            if ( wprev != 0 && !donemask[wprev - 1] )
            {
                phase[wprev - 1] = phase[wprev] - (fgrad[wprev] + fgrad[wprev - 1]) * oneover2;
                donemask[wprev - 1] = 1;

                heap_insert(h, w - 1);
                quickbreak--;
            }
        }
        else
        {
            if ( !donemask[w] )
            {
                ltfat_int wnext = w + M2;
                phase[w] = startphase[w] + (tgrad[w] + tgrad[wnext]) * oneover2;
                donemask[w] = 1;

                heap_insert(h, wnext);
                quickbreak--;
            }
        }
    }

    for (ltfat_int ii = 0; ii < M2; ii++)
    {
        if (donemask[ii] < 0)
        {
            phase[ii] = p->randphase[p->randphaseId++];
            p->randphaseId %= p->randphaseLen;
        }
    }

    return 0;
}

LTFAT_API int
rtpghiupdate_done(rtpghiupdate_plan** p)
{
    int status = LTFATERR_SUCCESS;
    rtpghiupdate_plan* pp;
    CHECKNULL(p); CHECKNULL(*p);
    pp = *p;
    if (pp->h)         heap_done(pp->h);
    if (pp->donemask)  ltfat_free(pp->donemask);
    if (pp->randphase) ltfat_free(pp->randphase);
    ltfat_free(pp);
    pp = NULL;
error:
    return status;
}


void
rtpghifgrad(const double* phase, ltfat_int M, double stretch,
                        double* fgrad)
{
    ltfat_int M2 = M / 2 + 1;

    for (ltfat_int m = 1; m < M2 - 1; m++)
        fgrad[m] = ( princarg(phase[m + 1] - phase[m]) +
                     princarg(phase[m]     - phase[m - 1]) )
                   / (2.0) * stretch;

    fgrad[0]      = phase[0] * stretch;
    fgrad[M2 - 1] = phase[M2 - 1] * stretch;
}

void
rtpghitgrad(const double* phase,
                        ltfat_int aanaprev, ltfat_int aananext, ltfat_int M,
                        double stretch, double* tgrad)
{
    ltfat_int M2 = M / 2 + 1;
    // a is asyn
    double asyn = aanaprev * stretch;

    double const1prev = 2.0 * M_PI * ((double) aanaprev) / M;
    double const1next = 2.0 * M_PI * ((double) aananext) / M;
    double const2 = 2.0 * M_PI * asyn / M;

    const double* pcol0 = phase;
    const double* pcol1 = phase + 1 * M2;
    const double* pcol2 = phase + 2 * M2;

    for (ltfat_int m = 0; m < M2; ++m)
        tgrad[m] = asyn * (
                       princarg(pcol2[m] - pcol1[m] - const1next * m) / (2.0 * aananext) -
                       princarg(pcol1[m] - pcol0[m] - const1prev * m) / (2.0 * aanaprev)
                   )
                   + const2 * m;
}

void
rtpghimagphase(const double* s, const double* phase,
                           ltfat_int L, LTFAT_COMPLEX* c)
{
    double* casreal = (double*) c;
    for (ltfat_int l = 0; l < L; l++)
    {
        casreal[2*l] = s[l] * cos(phase[l]);
        casreal[2*l+1] = s[l] * sin(phase[l]);
    }
}

/* LTFAT_API int */
/* rtpghioffline(const double* s, ltfat_int L, */
/*                              ltfat_int W, ltfat_int a, ltfat_int M, */
/*                              double gamma, double tol, int do_causal, */
/*                              LTFAT_COMPLEX* c) */
/* { */
/*     ltfat_int N = L / a; */
/*     ltfat_int M2 = M / 2 + 1; */
/*     rtpghi_state* p = NULL; */
/*     int status = LTFATERR_SUCCESS; */
/*     CHECKNULL(s); CHECKNULL(c); */
/*  */
/*     CHECKSTATUS( rtpghi_init(1, a, M, gamma, tol, do_causal, &p), */
/*                  "rtpghi init failed"); */
/*  */
/*     if (do_causal) */
/*     { */
/*         for (ltfat_int w = 0; w < W; w++) */
/*         { */
/*  */
/*             const double* schan = s + w * N * M2; */
/*             rtpghi_reset(p, &schan); */
/*  */
/*             for (ltfat_int n = 0; n < N; ++n) */
/*             { */
/*                 const double* sncol = schan + n * M2; */
/*                 LTFAT_COMPLEX* cncol =    c + n * M2 + w * N * M2; */
/*                 rtpghi_execute(p, sncol, cncol); */
/*             } */
/*         } */
/*     } */
/*     else */
/*     { */
/*         for (ltfat_int w = 0; w < W; w++) */
/*         { */
/*             const double* schan = s + w * N * M2; */
/*             rtpghi_reset(p, &schan); */
/*  */
/*             for (ltfat_int n = 0, nahead = 1; nahead < N; ++n, ++nahead) */
/*             { */
/*                 const double* sncol = schan + nahead * M2; */
/*                 LTFAT_COMPLEX* cncol =    c + n * M2 + w * N * M2; */
/*                 rtpghi_execute(p, sncol, cncol); */
/*             } */
/*  */
/*             rtpghi_execute(p, s + w * N * M2, c + (N - 1) * M2 + w * N * M2); */
/*         } */
/*     } */
/*  */
/*     rtpghi_done(&p); */
/* error: */
/*     return status; */
/* } */
